<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EasyMap ‚Äî Realtime map & directions</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin:0; font-family: Arial, Helvetica, sans-serif; }
    #map { height: 75vh; width: 100%; }
    header { background:#222; color:white; padding:10px 16px; display:flex; align-items:center; gap:12px; }
    .controls { padding:12px; display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    button { padding:8px 12px; border-radius:6px; border: none; background:#1976d2; color:white; cursor:pointer; font-size:14px; }
    button:hover { background:#1565c0; }
    button:disabled { background:#ccc; cursor:not-allowed; }
    input { padding:8px 10px; border-radius:6px; border:1px solid #ccc; min-width:200px; font-size:14px; }
    input:focus { border-color:#1976d2; outline:none; }
    .small { font-size:0.85rem; color:#eee; opacity:0.9 }
    #info { padding:8px 12px; background:#f5f5f5; border-top:1px solid #ddd; font-size:14px; }
    .label { font-weight:500; margin-right:5px; }
    .example { font-size:12px; color:#666; margin-left:5px; }
    .status { padding:4px 8px; background:#e3f2fd; border-radius:4px; margin-left:10px; font-size:12px; }
  </style>
</head>
<body>

<header>
  <div style="font-weight:700">EasyMap</div>
  <div class="small">Enter place names or coordinates (lat,lng)</div>
</header>

<div class="controls">
  <button id="locBtn">üìç Use My Location</button>
  <button id="clearBtn">üóëÔ∏è Clear All</button>
  
  <div style="display:flex; align-items:center; gap:8px;">
    <span class="label">From:</span>
    <input id="fromInput" placeholder="Enter city, address, or coordinates" />
    <span class="example">e.g. "New York" or "40.7128,-74.0060"</span>
  </div>
  
  <div style="display:flex; align-items:center; gap:8px;">
    <span class="label">To:</span>
    <input id="toInput" placeholder="Enter destination" />
  </div>
  
  <button id="routeBtn">üó∫Ô∏è Get Directions</button>
  <button id="saveBtn">üíæ Save Route</button>
  <span id="status" class="status" style="display:none;"></span>
</div>

<div id="map"></div>
<div id="info">
  <strong>Route Info:</strong> 
  Distance: <span id="distance">‚Äî</span> ‚Ä¢ 
  Duration: <span id="duration">‚Äî</span> ‚Ä¢
  <span id="routeDetails"></span>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
const BACKEND = (location.hostname === 'localhost') ? 'http://localhost:4000' : 'https://test-6-ldh3.onrender.com';

// initialize map
const map = L.map('map').setView([20.5937, 78.9629], 5); // default to India
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, 
  attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

let fromMarker = null, toMarker = null, routeLayer = null;
let currentFromLocation = null, currentToLocation = null;

// Status display functions
function showStatus(message, isError = false) {
  const status = document.getElementById('status');
  status.textContent = message;
  status.style.display = 'inline';
  status.style.background = isError ? '#ffebee' : '#e3f2fd';
  status.style.color = isError ? '#c62828' : '#1565c0';
  setTimeout(() => status.style.display = 'none', 5000);
}

// helper to parse input like "12.34,56.78"
function parseLatLng(s) {
  if(!s) return null;
  const parts = s.split(',').map(p=>p.trim());
  if(parts.length!==2) return null;
  const lat = parseFloat(parts[0]), lng = parseFloat(parts[1]);
  if(Number.isFinite(lat) && Number.isFinite(lng)) return [lat,lng];
  return null;
}

// Check if input looks like coordinates
function isCoordinates(input) {
  return /^-?\d+\.?\d*,-?\d+\.?\d*$/.test(input.trim());
}

// Geocode a place name to coordinates
async function geocodePlace(placeName) {
  try {
    console.log('Geocoding:', placeName);
    const response = await fetch(`${BACKEND}/geocode?q=${encodeURIComponent(placeName)}`);
    console.log('Geocoding response status:', response.status);
    
    if (!response.ok) {
      const error = await response.json();
      console.error('Geocoding error response:', error);
      throw new Error(error.error || 'Geocoding failed');
    }
    
    const result = await response.json();
    console.log('Geocoding result:', result);
    return result;
  } catch (error) {
    console.error('Geocoding fetch error:', error);
    throw new Error(`Could not find location "${placeName}": ${error.message}`);
  }
}

// Process location input (either coordinates or place name)
async function processLocationInput(input, isFrom = true) {
  if (!input.trim()) {
    throw new Error('Please enter a location');
  }

  let coords;
  let displayName = input;

  if (isCoordinates(input)) {
    // Parse coordinates directly
    const latLng = parseLatLng(input);
    if (!latLng) throw new Error('Invalid coordinate format');
    coords = { lat: latLng[0], lng: latLng[1] };
    displayName = `${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`;
  } else {
    // Geocode place name
    try {
      const geocoded = await geocodePlace(input);
      coords = { lat: geocoded.lat, lng: geocoded.lon };
      displayName = geocoded.display_name;
    } catch (error) {
      console.error('Geocoding error:', error);
      throw error;
    }
  }

  // Store the location data
  if (isFrom) {
    currentFromLocation = { coords, displayName, original: input };
  } else {
    currentToLocation = { coords, displayName, original: input };
  }

  return coords;
}

// Set marker on map
function setMarker(coords, isFrom = true) {
  const marker = L.marker([coords.lat, coords.lng], {draggable: true});
  
  if (isFrom) {
    if (fromMarker) map.removeLayer(fromMarker);
    fromMarker = marker.addTo(map).bindPopup('From: ' + (currentFromLocation?.displayName || 'Unknown')).openPopup();
    fromMarker.on('dragend', () => updateFromDrag());
  } else {
    if (toMarker) map.removeLayer(toMarker);
    toMarker = marker.addTo(map).bindPopup('To: ' + (currentToLocation?.displayName || 'Unknown')).openPopup();
    toMarker.on('dragend', () => updateToDrag());
  }
}

function updateFromDrag() {
  const pos = fromMarker.getLatLng();
  currentFromLocation = {
    coords: { lat: pos.lat, lng: pos.lng },
    displayName: `${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)}`,
    original: `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`
  };
  document.getElementById('fromInput').value = currentFromLocation.original;
}

function updateToDrag() {
  const pos = toMarker.getLatLng();
  currentToLocation = {
    coords: { lat: pos.lat, lng: pos.lng },
    displayName: `${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)}`,
    original: `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`
  };
  document.getElementById('toInput').value = currentToLocation.original;
}

// Click to set destination (simple behavior)
map.on('click', (e) => {
  const coords = { lat: e.latlng.lat, lng: e.latlng.lng };
  const coordString = `${coords.lat.toFixed(6)},${coords.lng.toFixed(6)}`;
  
  // Set as destination if no destination exists, otherwise set as origin
  if (!currentToLocation) {
    currentToLocation = {
      coords: coords,
      displayName: coordString,
      original: coordString
    };
    document.getElementById('toInput').value = coordString;
    setMarker(coords, false);
  } else {
    currentFromLocation = {
      coords: coords,
      displayName: coordString,
      original: coordString
    };
    document.getElementById('fromInput').value = coordString;
    setMarker(coords, true);
  }
});

// Clear all markers and data
document.getElementById('clearBtn').addEventListener('click', () => {
  if(fromMarker) { map.removeLayer(fromMarker); fromMarker = null; }
  if(toMarker) { map.removeLayer(toMarker); toMarker = null; }
  if(routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
  
  currentFromLocation = null;
  currentToLocation = null;
  
  document.getElementById('distance').textContent = '‚Äî';
  document.getElementById('duration').textContent = '‚Äî';
  document.getElementById('routeDetails').textContent = '';
  document.getElementById('fromInput').value = '';
  document.getElementById('toInput').value = '';
  showStatus('Cleared all markers and routes');
});

// Get current location
document.getElementById('locBtn').addEventListener('click', ()=> {
  if(!navigator.geolocation) return alert('Geolocation not supported');
  
  showStatus('Getting your location...');
  navigator.geolocation.getCurrentPosition(pos => {
    const coords = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    const coordString = `${coords.lat.toFixed(6)},${coords.lng.toFixed(6)}`;
    
    currentFromLocation = {
      coords: coords,
      displayName: 'Your Location',
      original: coordString
    };
    
    document.getElementById('fromInput').value = 'Your Location';
    map.setView([coords.lat, coords.lng], 14);
    setMarker(coords, true);
    showStatus('Location set as starting point');
  }, err => {
    showStatus('Could not get location: ' + err.message, true);
  });
});

// Get directions - MAIN FIX HERE
document.getElementById('routeBtn').addEventListener('click', async ()=> {
  const fromInput = document.getElementById('fromInput').value.trim();
  const toInput = document.getElementById('toInput').value.trim();
  
  if (!fromInput || !toInput) {
    showStatus('Please enter both start and destination', true);
    return;
  }

  // Disable button during processing
  const routeBtn = document.getElementById('routeBtn');
  const originalText = routeBtn.textContent;
  routeBtn.disabled = true;
  routeBtn.textContent = 'üîÑ Finding route...';

  // Show loading in info
  document.getElementById('distance').textContent = 'Loading...';
  document.getElementById('duration').textContent = 'Loading...';

  try {
    // FIXED: Always process locations first to ensure we have valid coordinates
    console.log('Processing FROM location:', fromInput);
    
    // Process FROM location
    if (!currentFromLocation || currentFromLocation.original !== fromInput) {
      try {
        await processLocationInput(fromInput, true);
        if (currentFromLocation && currentFromLocation.coords) {
          setMarker(currentFromLocation.coords, true);
        }
      } catch (error) {
        console.error('Error processing FROM location:', error);
        throw new Error(`From location error: ${error.message}`);
      }
    }
    
    console.log('Processing TO location:', toInput);
    
    // Process TO location
    if (!currentToLocation || currentToLocation.original !== toInput) {
      try {
        await processLocationInput(toInput, false);
        if (currentToLocation && currentToLocation.coords) {
          setMarker(currentToLocation.coords, false);
        }
      } catch (error) {
        console.error('Error processing TO location:', error);
        throw new Error(`To location error: ${error.message}`);
      }
    }

    // Verify we have both locations
    if (!currentFromLocation || !currentToLocation) {
      throw new Error('Failed to process one or both locations');
    }

    showStatus('Calculating route...');
    console.log('Requesting route with:', {
      from: currentFromLocation,
      to: currentToLocation
    });
    
    // FIXED: Use coordinates for routing if we have them, otherwise use original input
    let startParam, endParam;
    
    if (currentFromLocation.coords) {
      startParam = `${currentFromLocation.coords.lat},${currentFromLocation.coords.lng}`;
    } else {
      startParam = fromInput;
    }
    
    if (currentToLocation.coords) {
      endParam = `${currentToLocation.coords.lat},${currentToLocation.coords.lng}`;
    } else {
      endParam = toInput;
    }
    
    console.log('Route request params:', { start: startParam, end: endParam });
    
    const response = await fetch(`${BACKEND}/route?start=${encodeURIComponent(startParam)}&end=${encodeURIComponent(endParam)}`);
    console.log('Route response status:', response.status);
    
    if (!response.ok) {
      const error = await response.json();
      console.error('Route error response:', error);
      throw new Error(error.error || 'Routing failed');
    }
    
    const data = await response.json();
    console.log('Route data received:', data);
    
    // Remove existing route and add new one
    if(routeLayer) map.removeLayer(routeLayer);
    routeLayer = L.geoJSON(data.geometry, { 
      style: { color: '#1976d2', weight: 5, opacity: 0.8 } 
    }).addTo(map);
    
    // Fit map to show entire route
    map.fitBounds(routeLayer.getBounds().pad(0.1));
    
    // Update info display
    const distanceKm = (data.distance_meters / 1000).toFixed(2);
    const durationMins = Math.round(data.duration_seconds / 60);
    const durationHours = durationMins > 60 ? 
      `${Math.floor(durationMins/60)}h ${durationMins%60}m` : 
      `${durationMins} min`;
    
    document.getElementById('distance').textContent = `${distanceKm} km`;
    document.getElementById('duration').textContent = durationHours;
    
    const fromName = currentFromLocation.displayName.split(',')[0];
    const toName = currentToLocation.displayName.split(',')[0];
    document.getElementById('routeDetails').textContent = `From: ${fromName}... To: ${toName}...`;
    
    showStatus(`Route found! ${distanceKm} km, ${durationHours}`);
    
  } catch (error) {
    console.error('Routing error:', error);
    showStatus(error.message, true);
    document.getElementById('distance').textContent = '‚Äî';
    document.getElementById('duration').textContent = '‚Äî';
    document.getElementById('routeDetails').textContent = '';
  } finally {
    // Re-enable button
    routeBtn.disabled = false;
    routeBtn.textContent = originalText;
  }
});

// Save route
document.getElementById('saveBtn').addEventListener('click', async ()=> {
  if(!routeLayer) {
    showStatus('No route to save. Generate a route first.', true);
    return;
  }
  
  const name = prompt('Give a name for this route (optional)');
  if (name === null) return; // User cancelled
  
  const routeName = name || `${currentFromLocation?.displayName?.split(',')[0] || 'Unknown'} to ${currentToLocation?.displayName?.split(',')[0] || 'Unknown'}`;
  
  try {
    const geo = routeLayer.toGeoJSON();
    const response = await fetch(`${BACKEND}/save-route`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ name: routeName, geo })
    });
    
    const result = await response.json();
    showStatus(result.message || 'Route saved successfully!');
  } catch (error) {
    showStatus('Save failed: ' + error.message, true);
  }
});

// Auto-process input when user finishes typing (with debounce)
let fromTimeout, toTimeout;

document.getElementById('fromInput').addEventListener('input', (e) => {
  clearTimeout(fromTimeout);
  fromTimeout = setTimeout(async () => {
    if (e.target.value.trim() && currentFromLocation?.original !== e.target.value) {
      try {
        await processLocationInput(e.target.value, true);
        if (currentFromLocation) {
          setMarker(currentFromLocation.coords, true);
          showStatus(`From location set: ${currentFromLocation.displayName.split(',')[0]}`);
        }
      } catch (error) {
        console.log('Auto-geocoding error (will retry on route):', error.message);
      }
    }
  }, 1500);
});

document.getElementById('toInput').addEventListener('input', (e) => {
  clearTimeout(toTimeout);
  toTimeout = setTimeout(async () => {
    if (e.target.value.trim() && currentToLocation?.original !== e.target.value) {
      try {
        await processLocationInput(e.target.value, false);
        if (currentToLocation) {
          setMarker(currentToLocation.coords, false);
          showStatus(`To location set: ${currentToLocation.displayName.split(',')[0]}`);
        }
      } catch (error) {
        console.log('Auto-geocoding error (will retry on route):', error.message);
      }
    }
  }, 1500);
});

// Test backend connection on startup
async function testConnection() {
  try {
    console.log('Testing backend connection to:', BACKEND);
    const response = await fetch(`${BACKEND}/`);
    if (response.ok) {
      console.log('Backend connection successful');
      showStatus('Connected to mapping service');
    } else {
      throw new Error('Backend responded with error');
    }
  } catch (error) {
    console.error('Backend connection failed:', error);
    showStatus('Warning: Mapping service connection failed', true);
  }
}

// Load saved routes on startup (optional demo)
async function loadSavedRoutesList() {
  try {
    const res = await fetch(`${BACKEND}/routes`);
    if(!res.ok) return;
    const list = await res.json();
    if(list.length > 0) {
      console.log('Saved routes available:', list.length);
    }
  } catch(e) { 
    console.log('Could not load saved routes:', e.message);
  }
}

// Initialize
testConnection();
loadSavedRoutesList();

</script>
</body>
</html>