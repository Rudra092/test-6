<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Web Map – Real-time Navigation (OSM)</title>

<!-- Leaflet core -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Leaflet Routing Machine -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

<style>
  :root{
    --bg: rgba(255,255,255,.95);
    --shadow: 0 10px 30px rgba(0,0,0,.15);
    --radius: 14px;
    --accent: #2563eb;
    --green: #10b981;
    --dark: #111827;
    --top-height: 160px;
    --mobile-top-height: 180px;
  }
  
  *{box-sizing:border-box}
  html,body{height:100vh;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#111827;overflow:hidden}
  
  #map{
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    z-index:1;
  }

  /* Enhanced top controls with better mobile spacing */
  .top-controls {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: var(--bg);
    backdrop-filter: blur(10px);
    box-shadow: var(--shadow);
    padding: 12px;
    border-radius: 0 0 var(--radius) var(--radius);
  }

  .card{
    max-width: 600px;
    margin: 0 auto;
  }
  
  .row{
    display:grid; 
    grid-template-columns:1fr auto auto auto; 
    gap:8px; 
    align-items:stretch;
  }
  .row2{
    display:grid; 
    grid-template-columns:1fr auto; 
    gap:8px; 
    margin-top:8px;
    align-items:stretch;
  }
  .wrap{position:relative;flex:1;}
  
  input[type="text"]{
    width:100%; 
    padding:12px 14px; 
    border:1px solid #e5e7eb; 
    border-radius:12px;
    font-size:16px; /* Prevents zoom on iOS */
    outline:none; 
    background:#fff;
    min-height:44px; /* iOS touch target minimum */
    touch-action:manipulation;
  }
  input[type="text"]:focus{
    border-color:var(--accent); 
    box-shadow:0 0 0 3px rgba(37,99,235,.12);
  }
  
  button{
    padding:12px 14px; 
    border:0; 
    border-radius:12px; 
    cursor:pointer; 
    font-weight:600;
    background:var(--dark); 
    color:#fff; 
    white-space:nowrap;
    min-height:44px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:14px;
    touch-action:manipulation;
    transition:all 0.2s ease;
  }
  button:active{
    transform:scale(0.98);
  }
  .btn{background:#e5e7eb;color:#111827}
  .accent{background:var(--accent); color:#fff}
  .green{background:var(--green); color:#fff}
  .danger{background:#ef4444; color:#fff}
  .muted{color:#6b7280; font-size:12px;margin-top:8px;}

  /* Enhanced suggestions dropdown for mobile */
  .sug{
    position:absolute; 
    left:0; 
    right:0; 
    top:calc(100% + 8px);
    background:#fff; 
    border:1px solid #e5e7eb; 
    border-radius:14px; 
    box-shadow:var(--shadow);
    max-height:280px; 
    overflow-y:auto; 
    z-index:2000; 
    display:none;
    -webkit-overflow-scrolling:touch;
  }
  .s-item{
    padding:14px 16px; 
    cursor:pointer;
    border-bottom:1px solid #f3f4f6;
    min-height:60px;
    display:flex;
    flex-direction:column;
    justify-content:center;
  }
  .s-item:last-child{border-bottom:none;}
  .s-item:hover,.s-item:active{background:#f8fafc}
  .s-sub{display:block; font-size:12px; color:#6b7280; margin-top:3px;line-height:1.3;}

  /* Mobile-optimized navigation info panel */
  .nav-info {
    position: fixed;
    top: var(--top-height);
    left: 12px;
    right: 12px;
    z-index: 950;
    background: var(--bg);
    backdrop-filter: blur(10px);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 16px;
    display: none;
    max-width: 600px;
    margin: 0 auto;
  }

  .nav-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    flex-wrap:wrap;
    gap:8px;
  }

  .next-instruction {
    font-size: 16px;
    font-weight: 600;
    margin: 10px 0;
    color: var(--dark);
    line-height:1.4;
  }

  .nav-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 10px;
  }

  .stat {
    background: #f3f4f6;
    padding: 8px 12px;
    border-radius: 10px;
    font-size: 12px;
    font-weight: 600;
    text-align:center;
  }

  /* Mobile-first directions panel */
  .panel{
    position:fixed; 
    left:12px;
    right:12px;
    top:calc(var(--top-height) + 120px); 
    bottom:90px; 
    background:var(--bg); 
    backdrop-filter:blur(10px); 
    border-radius:var(--radius);
    box-shadow:var(--shadow); 
    padding:16px; 
    z-index:900; 
    overflow-y:auto; 
    display:none;
    -webkit-overflow-scrolling:touch;
  }
  .panel h3{margin:0 0 8px 0;font-size:18px;}
  .badge{
    display:inline-block; 
    padding:6px 10px; 
    border-radius:999px; 
    background:#eef2ff; 
    color:#3730a3; 
    font-weight:700; 
    font-size:12px; 
    margin-right:8px;
    margin-bottom:4px;
  }
  ol{margin:12px 0 0 0; padding:0 0 0 20px;}
  li{
    margin:8px 0; 
    line-height:1.5;
    padding:6px 0;
  }
  li.current{
    background:#e0f2fe; 
    padding:8px 10px; 
    border-radius:8px; 
    font-weight:600;
    margin-left:-10px;
  }

  /* Enhanced mobile navigation controls */
  .navbar{
    position:fixed; 
    left:12px;
    right:12px;
    bottom:12px;
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(100px, 1fr));
    gap:8px; 
    z-index:950;
    background:var(--bg); 
    box-shadow:var(--shadow); 
    border-radius:16px; 
    padding:12px;
  }

  /* Mobile speed indicator */
  .speed-indicator {
    position: fixed;
    bottom: 100px;
    right: 16px;
    background: var(--bg);
    backdrop-filter: blur(10px);
    border-radius: 50%;
    width: 60px;
    height: 60px;
    display: flex;
    flex-direction:column;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 14px;
    box-shadow: var(--shadow);
    z-index: 940;
    display: none;
  }
  .speed-indicator .unit{font-size:8px;color:#6b7280;margin-top:-2px;}

  /* Route progress bar */
  .route-progress {
    position: fixed;
    top: calc(var(--top-height) - 4px);
    left: 0;
    right: 0;
    height: 4px;
    background: #e5e7eb;
    z-index: 999;
  }

  .progress-bar {
    height: 100%;
    background: var(--green);
    width: 0%;
    transition: width 0.3s ease;
  }

  /* Enhanced mobile styles */
  @media (max-width:768px){
    :root{
      --top-height: var(--mobile-top-height);
    }
    
    .top-controls{
      padding: 10px;
    }
    
    .row{
      grid-template-columns:1fr;
      gap:8px;
    }
    .row2{
      grid-template-columns:1fr;
      gap:8px;
    }
    
    input[type="text"]{
      font-size:16px; /* Prevents zoom */
      padding:14px 16px;
    }
    
    button{
      padding:14px 16px;
      min-height:50px;
      font-size:15px;
    }
    
    .panel{
      top:calc(var(--mobile-top-height) + 20px);
      bottom:100px;
      left:8px;
      right:8px;
    }
    
    .nav-info {
      top: var(--mobile-top-height);
      left: 8px;
      right: 8px;
      padding:14px;
    }
    
    .navbar{
      left:8px;
      right:8px;
      bottom:8px;
      grid-template-columns:1fr 1fr;
      gap:6px;
      padding:10px;
    }
    
    .nav-stats{
      grid-template-columns:1fr 1fr;
      gap:8px;
    }
    
    .speed-indicator {
      bottom: 110px;
      right: 12px;
      width: 55px;
      height: 55px;
    }
    
    .next-instruction{
      font-size:15px;
    }
    
    /* Hide panel automatically on mobile when not navigating */
    .panel.auto-hide{
      display:none;
    }
  }

  /* Extra small screens (phones in portrait) */
  @media (max-width:480px){
    .top-controls{
      padding:8px;
    }
    
    .card{
      padding:0;
    }
    
    input[type="text"]{
      padding:12px 14px;
      min-height:48px;
    }
    
    button{
      padding:12px 14px;
      min-height:48px;
      font-size:14px;
    }
    
    .navbar{
      padding:8px;
      grid-template-columns:1fr 1fr;
      gap:6px;
    }
    
    .panel{
      top:calc(var(--mobile-top-height) + 10px);
      padding:12px;
    }
    
    .nav-info{
      padding:12px;
    }
    
    .speed-indicator{
      width:50px;
      height:50px;
      font-size:12px;
    }
  }

  /* Landscape orientation on mobile */
  @media (max-height:500px) and (orientation:landscape){
    :root{
      --mobile-top-height: 120px;
    }
    
    .top-controls{
      padding:6px;
    }
    
    .row{
      grid-template-columns:1fr auto auto auto;
      gap:6px;
    }
    .row2{
      grid-template-columns:1fr auto;
      gap:6px;
    }
    
    input[type="text"]{
      padding:10px 12px;
      min-height:40px;
    }
    
    button{
      padding:10px 12px;
      min-height:40px;
      font-size:13px;
    }
    
    .panel{
      top:calc(var(--mobile-top-height) + 10px);
      bottom:70px;
    }
    
    .navbar{
      grid-template-columns:repeat(5, 1fr);
      padding:6px;
    }
    
    .nav-info{
      top:calc(var(--mobile-top-height) - 10px);
    }
  }

  /* Custom user marker styles */
  .user-marker {
    width: 24px;
    height: 24px;
    background: #2563eb;
    border: 3px solid white;
    border-radius: 50%;
    box-shadow: 0 3px 10px rgba(0,0,0,0.3);
  }

  .user-marker.moving {
    background: #10b981;
  }

  .direction-arrow {
    width: 0;
    height: 0;
    border-left: 7px solid transparent;
    border-right: 7px solid transparent;
    border-bottom: 14px solid #2563eb;
    position: absolute;
    top: -18px;
    left: 50%;
    transform: translateX(-50%);
  }

  /* Touch improvements */
  .leaflet-control-zoom{
    border:none !important;
    box-shadow:var(--shadow) !important;
  }
  .leaflet-control-zoom a{
    width:50px !important;
    height:50px !important;
    line-height:50px !important;
    font-size:20px !important;
    border-radius:12px !important;
    margin:2px !important;
    background:var(--bg) !important;
    color:var(--dark) !important;
  }
  .leaflet-control-attribution{
    background:rgba(255,255,255,0.8) !important;
    border-radius:8px !important;
    font-size:10px !important;
  }

  /* Loading states */
  .loading{
    opacity:0.6;
    pointer-events:none;
  }
  
  /* Accessibility improvements */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }
  
  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    :root {
      --bg: rgba(0,0,0,0.9);
      --dark: #f9fafb;
    }
    
    html, body {
      background: #111827;
      color: #f9fafb;
    }
    
    input[type="text"] {
      background: #374151;
      border-color: #4b5563;
      color: #f9fafb;
    }
    
    .sug, .s-item {
      background: #374151;
      border-color: #4b5563;
      color: #f9fafb;
    }
    
    .btn {
      background: #4b5563;
      color: #f9fafb;
    }
  }
</style>
</head>
<body>
<div id="map"></div>

<!-- Route progress bar -->
<div class="route-progress">
  <div class="progress-bar" id="progressBar"></div>
</div>

<!-- Top controls -->
<div class="top-controls">
  <div class="card">
    <div class="row">
      <div class="wrap">
        <input id="from" type="text" placeholder="From (place or coordinates)" autocomplete="off">
        <div id="fromSug" class="sug"></div>
      </div>
      <button id="swap" class="btn" title="Swap">⇄</button>
      <button id="useCur" class="green" title="Use current location">📍</button>
      <button id="go" class="accent">Route</button>
    </div>
    <div class="row2">
      <div class="wrap">
        <input id="to" type="text" placeholder="To (place or coordinates)" autocomplete="off">
        <div id="toSug" class="sug"></div>
      </div>
      <button id="clear" class="btn">Clear</button>
    </div>
    <div class="muted">
      <strong>Tap Route</strong> to get directions • <strong>Tap map</strong> for quick destination
    </div>
  </div>
</div>

<!-- Navigation info panel -->
<div id="navInfo" class="nav-info">
  <div class="nav-header">
    <span class="badge" id="navDistance"></span>
    <span class="badge" id="navTime"></span>
    <button id="closeNavInfo" class="btn" style="padding:6px 10px;">✕</button>
  </div>
  <div class="next-instruction" id="nextInstruction">Get directions to start navigation</div>
  <div class="nav-stats">
    <div class="stat" id="currentSpeed">0 km/h</div>
    <div class="stat" id="eta">ETA: --</div>
    <div class="stat" id="remaining">-- km left</div>
  </div>
</div>

<!-- Directions panel -->
<div id="panel" class="panel">
  <h3>Route Instructions</h3>
  <div id="summary" class="muted"></div>
  <ol id="steps"></ol>
</div>

<!-- Speed indicator -->
<div id="speedIndicator" class="speed-indicator">
  <div id="speedText">0</div>
  <div class="unit">km/h</div>
</div>

<!-- Navigation controls -->
<div class="navbar">
  <button id="startNav" class="green">▶ Navigate</button>
  <button id="pauseNav" class="btn">⏸ Pause</button>
  <button id="stopNav" class="danger">■ Stop</button>
  <button id="mute" class="btn" title="Mute/Unmute">🔊</button>
  <button id="recenter" class="btn" title="Follow">🎯</button>
  <button id="compass" class="btn" title="North Up">🧭</button>
</div>

<script>
  // --- Enhanced Map setup ---
  const map = L.map('map', { 
    zoomControl: false,
    attributionControl: false,
    tap: true,
    tapTolerance: 15
  }).setView([20.5937, 78.9629], 5);
  
  L.control.zoom({ position: 'bottomright' }).addTo(map);
  L.control.attribution({ position: 'bottomright', prefix: false }).addTo(map);
  
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, 
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  // --- UI elements ---
  const elements = {
    from: document.getElementById('from'),
    to: document.getElementById('to'),
    fromSug: document.getElementById('fromSug'),
    toSug: document.getElementById('toSug'),
    go: document.getElementById('go'),
    clear: document.getElementById('clear'),
    swap: document.getElementById('swap'),
    useCur: document.getElementById('useCur'),
    panel: document.getElementById('panel'),
    summary: document.getElementById('summary'),
    steps: document.getElementById('steps'),
    navInfo: document.getElementById('navInfo'),
    nextInstruction: document.getElementById('nextInstruction'),
    navDistance: document.getElementById('navDistance'),
    navTime: document.getElementById('navTime'),
    currentSpeed: document.getElementById('currentSpeed'),
    eta: document.getElementById('eta'),
    remaining: document.getElementById('remaining'),
    closeNavInfo: document.getElementById('closeNavInfo'),
    progressBar: document.getElementById('progressBar'),
    speedIndicator: document.getElementById('speedIndicator'),
    speedText: document.getElementById('speedText'),
    startNav: document.getElementById('startNav'),
    pauseNav: document.getElementById('pauseNav'),
    stopNav: document.getElementById('stopNav'),
    mute: document.getElementById('mute'),
    recenter: document.getElementById('recenter'),
    compass: document.getElementById('compass')
  };

  // --- Enhanced State Management ---
  const state = {
    routingControl: null,
    currentRoute: null,
    userMarker: null,
    userPosition: null,
    userHeading: 0,
    watchId: null,
    navActive: false,
    navPaused: false,
    voiceMuted: false,
    followUser: true,
    compassMode: false, // true = north up, false = heading up
    nextInstructionIdx: 0,
    lastAnnouncementDistance: Infinity,
    routeStartTime: null,
    totalDistance: 0,
    distanceTraveled: 0,
    currentSpeed: 0,
    previousPositions: [],
    smoothingFactor: 0.3,
    isMobile: window.innerWidth <= 768
  };

  // --- Utility Functions ---
  function parseLatLon(text){
    const parts = text.split(',').map(s => parseFloat(s.trim()));
    if (parts.length === 2 && parts.every(n => !Number.isNaN(n))) return L.latLng(parts[0], parts[1]);
    return null;
  }

  function distance(a, b) {
    return map.distance(a, b);
  }

  function calculateBearing(start, end) {
    const startLat = start.lat * Math.PI / 180;
    const startLng = start.lng * Math.PI / 180;
    const endLat = end.lat * Math.PI / 180;
    const endLng = end.lng * Math.PI / 180;
    
    const dLng = endLng - startLng;
    
    const y = Math.sin(dLng) * Math.cos(endLat);
    const x = Math.cos(startLat) * Math.sin(endLat) - Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);
    
    return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
  }

  function smoothSpeed(newSpeed) {
    return state.currentSpeed + (newSpeed - state.currentSpeed) * state.smoothingFactor;
  }

  function formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
  }

  function formatDistance(meters) {
    if (meters >= 1000) return `${(meters/1000).toFixed(1)} km`;
    return `${Math.round(meters)} m`;
  }

  // Mobile detection and handling
  function updateMobileState() {
    state.isMobile = window.innerWidth <= 768;
    
    // Auto-hide panels on mobile when not navigating
    if (state.isMobile && !state.navActive) {
      setTimeout(() => {
        if (elements.panel.style.display === 'block' && !state.navActive) {
          elements.panel.classList.add('auto-hide');
        }
      }, 10000);
    }
  }

  // --- Enhanced Geocoding ---
  async function photonSearch(q){
    const url = new URL('https://photon.komoot.io/api/');
    url.searchParams.set('q', q);
    url.searchParams.set('limit','8');
    const res = await fetch(url);
    if(!res.ok) throw new Error('search failed');
    return res.json();
  }

  function renderSuggestions(box, features, onPick){
    box.innerHTML = '';
    if(!features || !features.length){ 
      box.style.display = 'none'; 
      return; 
    }
    features.forEach(f=>{
      const name = f.properties.name || f.properties.street || 'Unnamed';
      const ctx = [f.properties.city, f.properties.state, f.properties.country]
        .filter(Boolean).join(', ');
      const div = document.createElement('div');
      div.className = 's-item';
      div.innerHTML = `${name}<span class="s-sub">${ctx}</span>`;
      div.addEventListener('click', () => onPick(f));
      
      // Enhanced touch handling
      div.addEventListener('touchstart', (e) => {
        e.preventDefault();
        div.style.background = '#f8fafc';
      });
      div.addEventListener('touchend', () => {
        div.style.background = '';
        onPick(f);
      });
      
      box.appendChild(div);
    });
    box.style.display = 'block';
  }

  function attachAutocomplete(input, box){
    let timeout;
    input.addEventListener('input', ()=>{
      input.removeAttribute('data-lat');
      input.removeAttribute('data-lon');
      const q = input.value.trim();
      clearTimeout(timeout);
      if(q.length < 2){ 
        box.style.display='none'; 
        return; 
      }
      timeout = setTimeout(async ()=>{
        try{
          const data = await photonSearch(q);
          renderSuggestions(box, data.features, (f)=>{
            const [lon, lat] = f.geometry.coordinates;
            input.dataset.lat = lat;
            input.dataset.lon = lon;
            const label = (f.properties.name||'') + 
              (f.properties.city?`, ${f.properties.city}`:'') + 
              (f.properties.country?`, ${f.properties.country}`:'');
            input.value = label;
            box.style.display = 'none';
          });
        }catch{ 
          box.style.display='none'; 
        }
      }, 300);
    });

    input.addEventListener('keydown', e=>{
      if(e.key === 'Enter' && box.firstChild){ 
        e.preventDefault(); 
        box.firstChild.click(); 
      }
    });

    // Enhanced touch and click handling
    document.addEventListener('click', e=>{
      if(!box.contains(e.target) && e.target !== input) {
        box.style.display='none';
      }
    });
    
    document.addEventListener('touchstart', e=>{
      if(!box.contains(e.target) && e.target !== input) {
        box.style.display='none';
      }
    });
  }

  attachAutocomplete(elements.from, elements.fromSug);
  attachAutocomplete(elements.to, elements.toSug);

  async function geocodeIfNeeded(input){
    if(input.dataset.lat && input.dataset.lon) {
      return L.latLng(parseFloat(input.dataset.lat), parseFloat(input.dataset.lon));
    }
    const parsed = parseLatLon(input.value.trim());
    if(parsed) return parsed;
    
    const result = await photonSearch(input.value.trim());
    if(!result.features || !result.features[0]) {
      throw new Error('Place not found: ' + input.value.trim());
    }
    const [lon, lat] = result.features[0].geometry.coordinates;
    input.dataset.lat = lat;
    input.dataset.lon = lon;
    return L.latLng(lat, lon);
  }

  async function reverseGeocode(latlng){
    const url = new URL('https://nominatim.openstreetmap.org/reverse');
    url.searchParams.set('format','jsonv2');
    url.searchParams.set('lat', latlng.lat);
    url.searchParams.set('lon', latlng.lng);
    const res = await fetch(url, { 
      headers: { 'Accept-Language': 'en' }
    });
    if(!res.ok) return null;
    return res.json();
  }

  // --- Enhanced Routing ---
  function makeRoute(fromLL, toLL){
    if(state.routingControl){ 
      map.removeControl(state.routingControl); 
      state.routingControl = null; 
    }
    
    state.routingControl = L.Routing.control({
      waypoints: [fromLL, toLL],
      router: L.Routing.osrmv1({ 
        serviceUrl: 'https://router.project-osrm.org/route/v1'
      }),
      routeWhileDragging: false,
      addWaypoints: false,
      showAlternatives: false,
      show: false,
      lineOptions: { 
        styles:[{color:'#2563eb', opacity:0.8, weight:5}] 
      },
      createMarker: function(i, wp, n){
        const icon = i === 0 ? 
          L.divIcon({className: 'start-marker', html: '🚩', iconSize:[20,20]}) :
          L.divIcon({className: 'end-marker', html: '🏁', iconSize:[20,20]});
        return L.marker(wp.latLng, { icon, draggable:false });
      }
    }).addTo(map);

    state.routingControl.on('routesfound', e=>{
      state.currentRoute = e.routes[0];
      state.nextInstructionIdx = 0;
      state.totalDistance = state.currentRoute.summary.totalDistance;
      state.distanceTraveled = 0;
      
      const bounds = L.latLngBounds(state.currentRoute.coordinates);
      map.fitBounds(bounds, { padding:[80,80] });
      
      renderRoutePanel(state.currentRoute);
      elements.panel.style.display = 'block';
      elements.panel.classList.remove('auto-hide');
      
      updateNavigationInfo();
    });

    state.routingControl.on('routingerror', ()=> {
      alert('Routing failed. Try different locations.');
    });
  }

  function renderRoutePanel(route){
    const km = (route.summary.totalDistance/1000).toFixed(1);
    const min = Math.round(route.summary.totalTime/60);
    elements.summary.innerHTML = 
      `<span class="badge">${km} km</span><span class="badge">~${min} min</span> Instructions:`;
    
    elements.steps.innerHTML = '';
    (route.instructions || []).forEach((ins, idx)=>{
      const li = document.createElement('li');
      li.textContent = ins.text;
      li.id = `step-${idx}`;
      elements.steps.appendChild(li);
    });
  }

  // --- Enhanced Voice Navigation ---
  function speak(text, priority = false){
    if(state.voiceMuted || !('speechSynthesis' in window)) return;
    
    if(priority) window.speechSynthesis.cancel();
    
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'en-US';
    utterance.rate = 1.1;
    utterance.pitch = 1;
    window.speechSynthesis.speak(utterance);
  }

  // --- Enhanced Location Tracking ---
  function createUserMarker(position) {
    const icon = L.divIcon({
      className: 'user-marker',
      html: '<div class="direction-arrow"></div>',
      iconSize: [24, 24],
      iconAnchor: [12, 12]
    });
    
    return L.marker(position, { icon }).addTo(map);
  }

  function updateUserMarker(position, heading) {
    if (!state.userMarker) {
      state.userMarker = createUserMarker(position);
    } else {
      state.userMarker.setLatLng(position);
    }
    
    // Update marker rotation based on heading
    const markerElement = state.userMarker.getElement();
    if (markerElement) {
      const arrow = markerElement.querySelector('.direction-arrow');
      if (arrow && !isNaN(heading)) {
        arrow.style.transform = `translateX(-50%) rotate(${heading}deg)`;
      }
      
      // Add moving class when speed > 1 km/h
      const marker = markerElement.querySelector('.user-marker');
      if (marker) {
        if (state.currentSpeed > 1) {
          marker.classList.add('moving');
        } else {
          marker.classList.remove('moving');
        }
      }
    }
  }

  function calculateSpeedFromPositions() {
    if (state.previousPositions.length < 2) return 0;
    
    const now = Date.now();
    const recent = state.previousPositions.filter(p => now - p.timestamp < 5000);
    
    if (recent.length < 2) return 0;
    
    const oldest = recent[0];
    const newest = recent[recent.length - 1];
    const timeSpan = (newest.timestamp - oldest.timestamp) / 1000; // seconds
    const distance = map.distance(oldest.position, newest.position); // meters
    
    return timeSpan > 0 ? (distance / timeSpan) * 3.6 : 0; // km/h
  }

  function handleNavUpdate(userPosition) {
    if (!state.navActive || !state.currentRoute) return;
    
    const instructions = state.currentRoute.instructions || [];
    if (state.nextInstructionIdx >= instructions.length) return;
    
    const currentInstruction = instructions[state.nextInstructionIdx];
    const turnPoint = state.currentRoute.coordinates[currentInstruction.index];
    const distanceToTurn = distance(userPosition, turnPoint);
    
    // Progressive announcements
    if (distanceToTurn < 50 && state.lastAnnouncementDistance > 50) {
      speak(`In 50 meters, ${currentInstruction.text}`, true);
      state.lastAnnouncementDistance = 50;
    } else if (distanceToTurn < 150 && state.lastAnnouncementDistance > 150) {
      speak(`In 150 meters, ${currentInstruction.text}`);
      state.lastAnnouncementDistance = 150;
    } else if (distanceToTurn < 500 && state.lastAnnouncementDistance > 500) {
      speak(`In 500 meters, ${currentInstruction.text}`);
      state.lastAnnouncementDistance = 500;
    }
    
    // Move to next instruction
    if (distanceToTurn < 30) {
      // Highlight current instruction
      const steps = elements.steps.querySelectorAll('li');
      steps.forEach(step => step.classList.remove('current'));
      const currentStep = document.getElementById(`step-${state.nextInstructionIdx}`);
      if (currentStep) {
        currentStep.classList.add('current');
        currentStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      
      speak(currentInstruction.text, true);
      state.nextInstructionIdx++;
      state.lastAnnouncementDistance = Infinity;
      
      if (state.nextInstructionIdx >= instructions.length) {
        speak("You have arrived at your destination!", true);
        setTimeout(() => stopNavigation(), 3000);
      }
    }
    
    updateNavigationInfo();
  }

  function updateNavigationInfo() {
    if (!state.currentRoute) return;
    
    const remainingDistance = state.totalDistance - state.distanceTraveled;
    const remainingTime = state.currentRoute.summary.totalTime * (remainingDistance / state.totalDistance);
    
    elements.navDistance.textContent = formatDistance(remainingDistance);
    elements.navTime.textContent = formatTime(remainingTime);
    elements.currentSpeed.textContent = `${Math.round(state.currentSpeed)} km/h`;
    elements.remaining.textContent = `${formatDistance(remainingDistance)} left`;
    elements.speedText.textContent = Math.round(state.currentSpeed);
    
    // Update progress bar
    const progress = (state.distanceTraveled / state.totalDistance) * 100;
    elements.progressBar.style.width = `${Math.min(progress, 100)}%`;
    
    // Update ETA
    if (state.routeStartTime && remainingTime > 0) {
      const eta = new Date(Date.now() + remainingTime * 1000);
      elements.eta.textContent = `ETA: ${eta.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
    }
    
    // Update next instruction
    if (state.nextInstructionIdx < (state.currentRoute.instructions || []).length) {
      const nextInstr = state.currentRoute.instructions[state.nextInstructionIdx];
      elements.nextInstruction.textContent = nextInstr.text;
    } else {
      elements.nextInstruction.textContent = "Continue to destination";
    }
  }

  function startLocationTracking(){
    if(state.watchId) navigator.geolocation.clearWatch(state.watchId);
    if(!navigator.geolocation){ 
      alert('Geolocation not supported'); 
      return; 
    }
    
    state.watchId = navigator.geolocation.watchPosition(position => {
      const newPosition = L.latLng(position.coords.latitude, position.coords.longitude);
      const timestamp = Date.now();
      
      // Store position history
      state.previousPositions.push({ position: newPosition, timestamp });
      if (state.previousPositions.length > 10) {
        state.previousPositions.shift();
      }
      
      // Calculate heading if we have previous position
      if (state.userPosition) {
        const newHeading = calculateBearing(state.userPosition, newPosition);
        state.userHeading = newHeading;
      }
      
      state.userPosition = newPosition;
      
      // Calculate and smooth speed
      const newSpeed = calculateSpeedFromPositions();
      state.currentSpeed = smoothSpeed(newSpeed);
      
      // Update distance traveled
      if (state.navActive && state.previousPositions.length > 1) {
        const lastPos = state.previousPositions[state.previousPositions.length - 2];
        state.distanceTraveled += distance(lastPos.position, newPosition);
      }
      
      // Update user marker with smooth animation
      updateUserMarker(newPosition, state.userHeading);
      
      // Follow user if enabled
      if (state.followUser) {
        const zoom = Math.max(16, map.getZoom());
        if (state.compassMode) {
          // North up mode
          map.setView(newPosition, zoom, { animate: true, duration: 0.5 });
        } else {
          // Heading up mode - rotate map
          map.setView(newPosition, zoom, { animate: true, duration: 0.5 });
        }
      }
      
      // Update navigation if active
      if (state.navActive) {
        handleNavUpdate(newPosition);
      }
      
    }, error => {
      console.error('Location error:', error);
      const errorMessages = {
        1: 'Location access denied. Please enable location services.',
        2: 'Location unavailable. Please check your connection.',
        3: 'Location request timed out. Please try again.'
      };
      alert(errorMessages[error.code] || `Location error: ${error.message}`);
    }, { 
      enableHighAccuracy: true, 
      maximumAge: 1000, 
      timeout: 15000 
    });
  }

  function stopLocationTracking(){
    if(state.watchId){ 
      navigator.geolocation.clearWatch(state.watchId); 
      state.watchId = null; 
    }
  }

  function startNavigation() {
    if (!state.currentRoute) {
      alert('Get a route first');
      return;
    }
    
    state.navActive = true;
    state.navPaused = false;
    state.followUser = true;
    state.nextInstructionIdx = 0;
    state.lastAnnouncementDistance = Infinity;
    state.routeStartTime = Date.now();
    state.distanceTraveled = 0;
    
    elements.navInfo.style.display = 'block';
    elements.speedIndicator.style.display = 'flex';
    elements.startNav.style.display = 'none';
    elements.pauseNav.style.display = 'inline-flex';
    elements.stopNav.style.display = 'inline-flex';
    
    // Auto-hide directions panel on mobile during navigation
    if (state.isMobile) {
      setTimeout(() => {
        if (elements.panel.style.display === 'block') {
          elements.panel.style.display = 'none';
        }
      }, 5000);
    }
    
    speak('Navigation started', true);
    startLocationTracking();
    updateNavigationInfo();
  }

  function pauseNavigation() {
    if (!state.navActive) return;
    
    state.navPaused = !state.navPaused;
    
    if (state.navPaused) {
      speak('Navigation paused');
      stopLocationTracking();
      elements.pauseNav.textContent = '▶ Resume';
    } else {
      speak('Navigation resumed');
      startLocationTracking();
      elements.pauseNav.textContent = '⏸ Pause';
    }
  }

  function stopNavigation() {
    if (!state.navActive) return;
    
    state.navActive = false;
    state.navPaused = false;
    state.followUser = false;
    state.nextInstructionIdx = 0;
    state.routeStartTime = null;
    state.distanceTraveled = 0;
    
    elements.navInfo.style.display = 'none';
    elements.speedIndicator.style.display = 'none';
    elements.startNav.style.display = 'inline-flex';
    elements.pauseNav.style.display = 'none';
    elements.stopNav.style.display = 'none';
    elements.pauseNav.textContent = '⏸ Pause';
    elements.progressBar.style.width = '0%';
    
    // Remove current step highlighting
    const steps = elements.steps.querySelectorAll('li');
    steps.forEach(step => step.classList.remove('current'));
    
    speak('Navigation stopped');
    stopLocationTracking();
  }

  // --- Enhanced Event Listeners ---
  
  // Route planning
  elements.go.addEventListener('click', async () => {
    try {
      elements.go.disabled = true;
      elements.go.textContent = 'Routing…';
      elements.go.classList.add('loading');
      
      const fromLL = await geocodeIfNeeded(elements.from);
      const toLL = await geocodeIfNeeded(elements.to);
      makeRoute(fromLL, toLL);
    } catch(e) {
      alert(e.message || 'Failed to create route');
    } finally {
      elements.go.disabled = false;
      elements.go.textContent = 'Route';
      elements.go.classList.remove('loading');
    }
  });

  elements.clear.addEventListener('click', () => {
    elements.from.value = '';
    elements.to.value = '';
    elements.from.removeAttribute('data-lat');
    elements.from.removeAttribute('data-lon');
    elements.to.removeAttribute('data-lat');
    elements.to.removeAttribute('data-lon');
    
    // Hide suggestions
    elements.fromSug.style.display = 'none';
    elements.toSug.style.display = 'none';
    
    if (state.routingControl) {
      map.removeControl(state.routingControl);
      state.routingControl = null;
    }
    
    state.currentRoute = null;
    state.nextInstructionIdx = 0;
    elements.panel.style.display = 'none';
    
    if (state.navActive) stopNavigation();
  });

  elements.swap.addEventListener('click', () => {
    const tempValue = elements.from.value;
    const tempLat = elements.from.dataset.lat;
    const tempLon = elements.from.dataset.lon;
    
    elements.from.value = elements.to.value;
    elements.to.value = tempValue;
    
    if (elements.to.dataset.lat && elements.to.dataset.lon) {
      elements.from.dataset.lat = elements.to.dataset.lat;
      elements.from.dataset.lon = elements.to.dataset.lon;
    } else {
      elements.from.removeAttribute('data-lat');
      elements.from.removeAttribute('data-lon');
    }
    
    if (tempLat && tempLon) {
      elements.to.dataset.lat = tempLat;
      elements.to.dataset.lon = tempLon;
    } else {
      elements.to.removeAttribute('data-lat');
      elements.to.removeAttribute('data-lon');
    }
    
    // Hide suggestions after swap
    elements.fromSug.style.display = 'none';
    elements.toSug.style.display = 'none';
  });

  elements.useCur.addEventListener('click', () => {
    if (!navigator.geolocation) {
      alert('Geolocation not supported');
      return;
    }
    
    elements.useCur.disabled = true;
    elements.useCur.textContent = 'Getting…';
    
    navigator.geolocation.getCurrentPosition(async pos => {
      const position = L.latLng(pos.coords.latitude, pos.coords.longitude);
      map.setView(position, 16);
      
      if (state.userMarker) {
        state.userMarker.setLatLng(position);
      } else {
        updateUserMarker(position, 0);
      }
      
      try {
        const result = await reverseGeocode(position);
        const label = result?.display_name || 
          `${position.lat.toFixed(5)}, ${position.lng.toFixed(5)}`;
        elements.from.value = label;
        elements.from.dataset.lat = position.lat;
        elements.from.dataset.lon = position.lng;
      } catch {
        elements.from.value = `${position.lat.toFixed(5)}, ${position.lng.toFixed(5)}`;
        elements.from.dataset.lat = position.lat;
        elements.from.dataset.lon = position.lng;
      }
      
      elements.useCur.disabled = false;
      elements.useCur.textContent = '📍';
    }, err => {
      alert(`Location error: ${err.message}`);
      elements.useCur.disabled = false;
      elements.useCur.textContent = '📍';
    }, {
      enableHighAccuracy: true,
      timeout: 15000
    });
  });

  // Navigation controls
  elements.startNav.addEventListener('click', startNavigation);
  elements.pauseNav.addEventListener('click', pauseNavigation);
  elements.stopNav.addEventListener('click', stopNavigation);

  elements.mute.addEventListener('click', () => {
    state.voiceMuted = !state.voiceMuted;
    elements.mute.textContent = state.voiceMuted ? '🔇' : '🔊';
    elements.mute.title = state.voiceMuted ? 'Unmute' : 'Mute';
    speak(state.voiceMuted ? 'Voice muted' : 'Voice unmuted');
  });

  elements.recenter.addEventListener('click', () => {
    state.followUser = !state.followUser;
    elements.recenter.textContent = state.followUser ? '🎯' : '👁️';
    elements.recenter.title = state.followUser ? 'Following' : 'Free View';
    
    if (state.followUser && state.userPosition) {
      map.setView(state.userPosition, Math.max(16, map.getZoom()));
    }
  });

  elements.compass.addEventListener('click', () => {
    state.compassMode = !state.compassMode;
    elements.compass.textContent = state.compassMode ? '🧭' : '↗️';
    elements.compass.title = state.compassMode ? 'North Up' : 'Heading Up';
  });

  elements.closeNavInfo.addEventListener('click', () => {
    elements.navInfo.style.display = 'none';
  });

  // Enhanced keyboard shortcuts
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT') return; // Don't interfere with input fields
    
    switch(e.key) {
      case 'Enter':
        if (!state.navActive) elements.go.click();
        break;
      case 'Escape':
        if (state.navActive) stopNavigation();
        else if (elements.panel.style.display === 'block') {
          elements.panel.style.display = 'none';
        }
        break;
      case ' ': // Spacebar
        e.preventDefault();
        if (state.navActive) pauseNavigation();
        break;
      case 'c':
      case 'C':
        elements.clear.click();
        break;
    }
  });

  // Enhanced map interactions
  map.on('click', async (e) => {
    if (!elements.to.value.trim()) {
      const position = e.latlng;
      try {
        const result = await reverseGeocode(position);
        const label = result?.display_name || 
          `${position.lat.toFixed(5)}, ${position.lng.toFixed(5)}`;
        elements.to.value = label;
        elements.to.dataset.lat = position.lat;
        elements.to.dataset.lon = position.lng;
        
        // Auto-focus the route button on mobile after selecting destination
        if (state.isMobile && elements.from.value.trim()) {
          elements.go.focus();
        }
      } catch {
        elements.to.value = `${position.lat.toFixed(5)}, ${position.lng.toFixed(5)}`;
        elements.to.dataset.lat = position.lat;
        elements.to.dataset.lon = position.lng;
      }
    }
  });

  // Stop following when user manually moves map
  map.on('dragstart', () => {
    if (state.followUser) {
      state.followUser = false;
      elements.recenter.textContent = '👁️';
      elements.recenter.title = 'Free View';
    }
  });

  // Enhanced resize handling
  function handleResize() {
    const newIsMobile = window.innerWidth <= 768;
    
    if (newIsMobile !== state.isMobile) {
      state.isMobile = newIsMobile;
      updateMobileState();
    }
    
    // Adjust map size
    setTimeout(() => {
      map.invalidateSize();
    }, 100);
  }

  window.addEventListener('resize', handleResize);
  window.addEventListener('orientationchange', () => {
    setTimeout(handleResize, 500);
  });

  // Handle visibility change (when app goes to background/foreground)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // App went to background - reduce location update frequency
      if (state.watchId) {
        stopLocationTracking();
      }
    } else {
      // App came to foreground - resume normal operation
      if (state.navActive && !state.navPaused) {
        startLocationTracking();
      }
    }
  });

  // Touch and interaction improvements
  function addTouchFeedback(element) {
    element.addEventListener('touchstart', function(e) {
      this.style.transform = 'scale(0.98)';
      this.style.opacity = '0.8';
    });
    
    element.addEventListener('touchend', function(e) {
      this.style.transform = '';
      this.style.opacity = '';
    });
    
    element.addEventListener('touchcancel', function(e) {
      this.style.transform = '';
      this.style.opacity = '';
    });
  }

  // Add touch feedback to all buttons
  document.querySelectorAll('button').forEach(addTouchFeedback);

  // Prevent zoom on double tap for better UX
  let lastTap = 0;
  document.addEventListener('touchend', function (e) {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    if (tapLength < 500 && tapLength > 0) {
      e.preventDefault();
    }
    lastTap = currentTime;
  });

  // Initialize
  updateMobileState();
  handleResize();

  // PWA support - register service worker if available
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js')
        .then(() => console.log('SW registered'))
        .catch(() => console.log('SW registration failed'));
    });
  }

  // Handle network status
  function updateOnlineStatus() {
    if (!navigator.onLine) {
      const offlineNotice = document.createElement('div');
      offlineNotice.className = 'offline-notice';
      offlineNotice.textContent = 'Offline - Limited functionality';
      offlineNotice.style.cssText = `
        position: fixed;
        top: calc(var(--top-height) + 10px);
        left: 50%;
        transform: translateX(-50%);
        background: #f59e0b;
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        z-index: 9999;
        font-size: 12px;
        font-weight: 600;
      `;
      document.body.appendChild(offlineNotice);
      
      setTimeout(() => {
        if (offlineNotice.parentNode) {
          offlineNotice.remove();
        }
      }, 5000);
    }
  }

  window.addEventListener('online', updateOnlineStatus);
  window.addEventListener('offline', updateOnlineStatus);

</script>
</body>
</html>